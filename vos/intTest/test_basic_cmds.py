from vos.commands import vls, vcp, vmkdir, vrm, vrmdir, vchmod, vmv
from six import StringIO
from cadcutils import net
from mock import patch, Mock
import pytest
import sys
import os
import logging
import time
import filecmp
import shutil
import getpass
import hashlib

THIS_DIR = os.path.dirname(os.path.realpath(__file__))
DATA_DIR = os.path.join(THIS_DIR, "data")

cert1 = os.path.join(THIS_DIR, "certs/travis_inttest_proxy1.pem")
cert2 = os.path.join(THIS_DIR, "certs/travis_inttest_proxy2.pem")

user = getpass.getuser()
basedir = "vos:adriand"
testdir = os.path.join(basedir, "cadcIntTest")
container_name = '{}-{}'.format(user, time.strftime('%Y-%m-%dT%H-%M-%S'))
container = os.path.join(testdir, container_name)
tmp_dir = os.path.join('/tmp', 'test-{}'.format(container_name))

logger = logging.getLogger('vos')
logger.setLevel(logging.INFO)

# name of users
USER1 = 'cadcinttest1'
USER2 = 'cadcinttest2'
# access control groups
GR = 'CadcIT' # CadcIntTest1 and CadcIntTest2 members
GR1 = 'CadcIT1' # CadcIntTest1 member
GR2 = 'CadcIT2' # CadcIntTest2 member

class MyExitError(Exception):

    def __init__(self):
        self.message = "MyExitError"

# to capture the output of executing a command, sys.exit is patched to
# throw an MyExitError exception. The number of such exceptions is based
# on the number of commands and the number of times they are invoked
outputs = [MyExitError] * 100


@pytest.fixture(scope='module')
def work_dir():
    """
    creates work directory on vospace
    :return:
    """

    # check test sandbox dir exists and it's accessible by both users
    exec_cmd(vls, cert1, '{}'.format(testdir))
    exec_cmd(vls, cert2, '{}'.format(testdir))

    # create the test container specific to this run
    logger.info('Test container: {}'.format(container))
    out = exec_cmd(vls, cert1, '{}'.format(container), 1)
    assert 'NodeNotFound' in out

    exec_cmd(vmkdir, cert1, '{}'.format(container))
    out = exec_cmd(vls, cert1, '-l {}'.format(testdir))
    assert_line(container_name, ['drw-rw----', USER1, GR, GR], out)

    os.makedirs(tmp_dir)

    yield container

    # tear down part
    # remove test container
    print ('Tearing down test container')
    exec_cmd(vrmdir, cert1, container)

    shutil.rmtree(tmp_dir)


def assert_line(file, expected_fields, actual_output):
    """
    Checks if expected fields are present in the actual line generated by
    an vls -l command
    :param file: name of the file to look for in actual output. If not present
    it checks every entry
    :param expected_fields: expected fields in the line. None values match
    all the values in the line.
    :param actual_output: actual generated line or lines
    :raise AssertionError
    """
    found = False
    if not file:
        file = ''
    for line in actual_output.split('\n'):
        if (len(line.strip()) > 0) and (file in line):
            actual_fields = line.split()
            for i, field in enumerate(expected_fields):
                if field is not None:
                    assert field == actual_fields[i]
            found = True
    assert found


def exec_cmd(command, cert=None, args=None, return_status=0):
    """
    Executes vos command and captures and returns the output
    :param command: function to run
    :param cert: certificate to use
    :param args: other args to pass to sys.argv as a string
    :param return_status: expected return status due to error
    :return: output of executing the command
    """
    cert_flag = ''
    if cert:
        cert_flag = '--certfile {}'.format(cert)
    sys.argv = '{} {} {}'.format(command.__name__, cert_flag, args).split()
    try:
        with patch('sys.stdout', new_callable=StringIO) as stdout_mock:
            command()
    except SystemExit:
        # an early exit is expected only if return_status is not 0
        assert return_status != 0
    output = stdout_mock.getvalue()
    logger.debug('Command output: {}'.format(output))
    return output


def atest_container(work_dir):
    """ Some basic operations on the test container. """
    # ensure that the work_dir is not publicly readable
    out = exec_cmd(vls, cert1, '-l {}'.format(os.path.dirname(work_dir)))
    # the mask from the parent directory
    assert_line(container_name, ['drw-rw----', USER1, GR, GR], out)

    # check permissions are inherited
    exec_cmd(vmkdir, cert1, '{}/{}'.format(work_dir, 'pub'))

    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line(None, ['drw-rw----', USER1, GR, GR], out)

    # create a private directory with different permissions
    exec_cmd(vmkdir, cert1, '{}/{}'.format(work_dir, 'priv'))

    # change permissions
    # remove permissions
    exec_cmd(vchmod, cert1, 'g-rw {}/{}'.format(work_dir, 'priv'))

    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line('priv', ['drw-------', USER1, 'NONE', 'NONE'], out)

    # add permissions
    exec_cmd(vchmod, cert1, 'g+r {}/{} {}'.format(work_dir, 'priv', GR2))
    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line('priv', ['drw-r-----', USER1, GR2, 'NONE'], out)

    # change permission
    exec_cmd(vchmod, cert1, 'g+r {}/{} {}'.format(work_dir, 'priv', GR1))

    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line('priv', ['drw-r-----', USER1, GR1, 'NONE'], out)

    # remove empty directory
    out = exec_cmd(vrmdir, cert1, '{}/priv'.format(work_dir))
    out = exec_cmd(vls, cert1, '{}/priv'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # remove non-empty directory
    exec_cmd(vmkdir, cert1, '{}/pub/test'.format(work_dir))
    out = exec_cmd(vls, cert1, '-l {}/pub'.format(work_dir))
    assert_line('test', ['drw-rw----', USER1, GR, GR], out)

    exec_cmd(vrmdir, cert1, '{}/pub'.format(work_dir))
    out = exec_cmd(vls, cert1, '{}/pub'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # delete non-existing directory
    exec_cmd(vrmdir, cert1, '{}/pub'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # delete non-existing file
    exec_cmd(vrm, cert1, '{}/nofile.txt'.format(work_dir), 1)
    assert 'NodeNotFound' in out


def atest_file_copy(work_dir):
    """ Tests copying a file to the container and back."""
    local_file_name = 'something.png'
    local_file = os.path.join(DATA_DIR, local_file_name)
    remote_file = '{}/{}'.format(work_dir, local_file_name)
    exec_cmd(vcp, cert1, '{} {}'.format(local_file, work_dir))
    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line(local_file_name, ['-rw-rw----', USER1, GR, GR, '497927'], out)

    tmp_file = os.path.join(tmp_dir, local_file_name)
    # copy the file back to the local file system and compare with original
    exec_cmd(vcp, cert1, '{} {}'.format(remote_file, tmp_dir))
    assert filecmp.cmp(local_file, tmp_file)

    # repeat the tests with the quick flag
    exec_cmd(vrm, cert1, '{}/{}'.format(work_dir, local_file_name))
    out = exec_cmd(vls, cert1, '{}/{}'.format(container, local_file_name), 1)
    assert 'NodeNotFound' in out

    os.remove(tmp_file)
    exec_cmd(vcp, cert1, '--quick {} {}'.format(local_file, work_dir))
    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line(local_file_name, ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # copy the file back to the local file system and compare with original
    exec_cmd(vcp, cert1, '--quick {} {}'.format(remote_file, tmp_dir))
    assert filecmp.cmp(local_file, tmp_file)

    # check download with a wildcard and override
    exec_cmd(vcp, cert1, '--quick {} {}'.\
        format(remote_file.replace('png', '*'), tmp_dir))

    assert filecmp.cmp(local_file, tmp_file)
    os.remove(tmp_file)


def atest_zero_lenght_files(work_dir):
    src_zerosize_file_name = 'src_zerosize.txt'
    src_zerosize_file = os.path.join(tmp_dir, src_zerosize_file_name)

    # create zero size file
    open(src_zerosize_file, 'w')
    exec_cmd(vcp, cert=cert1,
             args='--quick {} {}'.format(src_zerosize_file, work_dir))
    out = exec_cmd(vls, cert=cert1, args='-l {}'.format(work_dir))
    assert_line(src_zerosize_file_name,
                ['-rw-rw----', USER1, GR, GR, '0', None, None,
                 None, src_zerosize_file_name], out)

    # repeat
    exec_cmd(vcp, cert=cert1,
             args='--quick {} {}'.format(src_zerosize_file, work_dir))
    out = exec_cmd(vls, cert=cert1, args='-l {}'.format(work_dir))
    assert_line(src_zerosize_file_name,
                ['-rw-rw----', USER1, GR, GR, '0', None, None,
                 None, src_zerosize_file_name], out)

    # download
    dest_file = os.path.join(tmp_dir, 'dest_zerosize.txt')
    exec_cmd(vcp, cert1, '{}/{} {}'.format(work_dir,
             src_zerosize_file_name, dest_file))
    assert filecmp.cmp(src_zerosize_file, dest_file)

    # change the size of the file and repeat
    with open(src_zerosize_file, 'w') as f:
        f.write('Test')
    exec_cmd(vcp, cert=cert1,
             args='--quick {} {}'.format(src_zerosize_file, work_dir))
    out = exec_cmd(vls, cert=cert1, args='-l {}'.format(work_dir))
    assert_line(src_zerosize_file_name,
                ['-rw-rw----', USER1, GR, GR, '4', None, None,
                 None, src_zerosize_file_name], out)

    # download
    exec_cmd(vcp, cert1, '{}/{} {}'.format(work_dir,
                                           src_zerosize_file_name, dest_file))
    assert filecmp.cmp(src_zerosize_file, dest_file)

    # make it back to size zero and repeat
    os.remove(src_zerosize_file)
    open(src_zerosize_file, 'w')
    exec_cmd(vcp, cert=cert1,
            args='--quick {} {}'.format(src_zerosize_file, work_dir))
    out = exec_cmd(vls, cert=cert1, args='-l {}'.format(work_dir))
    assert_line(src_zerosize_file_name,
                ['-rw-rw----', USER1, GR, GR, '0', None, None,
                 None, src_zerosize_file_name], out)
    # download
    exec_cmd(vcp, cert1, '{}/{} {}'.format(work_dir,
                                           src_zerosize_file_name, dest_file))
    assert filecmp.cmp(src_zerosize_file, dest_file)


def atest_cutout_downloads(work_dir):
    """
    Uploads a test file and performs cutout operations
    :param work_dir:
    :return:
    """
    src_cutout_file_name = 'cutout_test.fits'
    src_cutout_file = os.path.join(DATA_DIR, src_cutout_file_name)

    exec_cmd(vcp, cert1, '{} {}'.format(src_cutout_file, work_dir))
    out = exec_cmd(vls, cert1, '-l {}'.format(work_dir))
    assert_line(src_cutout_file_name, ['-rw-rw----', USER1, GR, GR], out)

    # download cutout
    cutout_file = os.path.join(tmp_dir, 'cut.fits')
    exec_cmd(vcp, cert1, '{}/{}[1] {}'.format(work_dir, src_cutout_file_name,
                                              cutout_file))

    assert '7eacb9c83d782bb4c927378a7073c9a1' == \
        hashlib.md5(open(cutout_file, 'rb').read()).hexdigest()
    os.remove(cutout_file)

    # repeat with different cutout and use wild cards
    cutout_file = os.path.join(tmp_dir, 'cut.fits')
    out = exec_cmd(vcp, cert1, '{}/cut*fits[1:10,1:10] {}'.format(
        work_dir, cutout_file))

    assert '5e2a31e042bc26193089c3fd6287e5a8' == \
           hashlib.md5(open(cutout_file, 'rb').read()).hexdigest()
    os.remove(cutout_file)


def atest_move(work_dir):
    local_test_file = os.path.join(DATA_DIR, 'something.png')
    exec_cmd(vmkdir, cert1, '{}/a'.format(work_dir))
    exec_cmd(vmkdir, cert1, '{}/a/aa'.format(work_dir))
    exec_cmd(vcp, cert1, '{} {}/a/aa/aaa'.format(local_test_file, work_dir))
    out = exec_cmd(vls, cert1, '-l {}/a/aa'.format(work_dir))
    assert_line('aaa', ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # mv (rename) file
    exec_cmd(vmv, cert1, '{0}/a/aa/aaa {0}/a/aa/bbb'.format(work_dir))
    out = exec_cmd(vls, cert1, '-l {}/a/aa'.format(work_dir))
    assert_line('bbb', ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # mv (rename) subdirectory
    exec_cmd(vmv, cert1, '{0}/a/aa {0}/a/bb'.format(work_dir))
    out = exec_cmd(vls, cert1, '-l {}/a/bb'.format(work_dir))
    assert_line('bbb', ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # mv (rename) parent directory
    exec_cmd(vmv, cert1, '{0}/a {0}/b'.format(work_dir))
    out = exec_cmd(vls, cert1, '-l {}/b/bb'.format(work_dir))
    assert_line('bbb', ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # mv data from one directory to another
    exec_cmd(vcp, cert1, '{} {}/aaa'.format(local_test_file, work_dir))
    exec_cmd(vmv, cert1, '{0}/aaa {0}/b/bb/'.format(work_dir))
    out = exec_cmd(vls, cert1, '-l {}/b/bb'.format(work_dir))
    assert_line('aaa', ['-rw-rw----', USER1, GR, GR, '497927'], out)
    assert_line('bbb', ['-rw-rw----', USER1, GR, GR, '497927'], out)
    out = exec_cmd(vls, cert1, '{}/aaa'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # Error cases
    # mv data when destination data node exists (duplicate node error)
    # mv data node to existing data node
    out = exec_cmd(vmv, cert1, '{0}/b/bb/aaa {0}/b/bb/bbb'.format(work_dir), 1)
    assert 'DuplicateNode destination is not a container' in out
    out = exec_cmd(vls, cert1, '-l {}/b/bb'.format(work_dir))
    assert_line('aaa', ['-rw-rw----', USER1, GR, GR, '497927'], out)
    assert_line('bbb', ['-rw-rw----', USER1, GR, GR, '497927'], out)

    # mv container node to existing data node
    exec_cmd(vmkdir, cert1, '{}/a'.format(work_dir))
    out = exec_cmd(vmv, cert1, '{0}/a {0}/b/bb/bbb'.format(work_dir), 1)
    assert 'DuplicateNode destination is not a container' in out

    # circular move
    out = exec_cmd(vmv, cert1, '{0}/b {0}/b/bb'.format(work_dir), 1)
    # not a very informative message
    assert 'Invalid Argument (target node is not a DataNode)' in out

    # no source node
    out = exec_cmd(vmv, cert1, '{0}/cc {0}/b'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # no destination node
    out = exec_cmd(vmv, cert1, '{0}/b {0}/c/cc'.format(work_dir), 1)
    assert 'NodeNotFound' in out

    # source is local directory
    out = exec_cmd(vmv, cert1, '/tmp {}'.format(work_dir), 1)
    assert 'No scheme in /tmp' in out

    # destination is local directory
    out = exec_cmd(vmv, cert1, '{}/b /tmp'.format(work_dir), 1)
    # Another non information message
    assert 'InternalFault (invalid direction: Direction[/tmp])' in out

    # source and destination are local directories
    out = exec_cmd(vmv, cert1, '. /tmp', 1)
    assert 'No scheme in .' in out


def test_access(work_dir):
    # test user only access directory
    user1_dir = 'user1'
    test_file_name = 'something.png'
    test_file = os.path.join(DATA_DIR, test_file_name)
    exec_cmd(vmkdir, cert1, '{}/{}'.format(work_dir, user1_dir))
    exec_cmd(vchmod, cert1, 'og-wr {}/{}'.format(work_dir, user1_dir))
    exec_cmd(vcp, cert1, '{} {}/{}/'.format(test_file, work_dir, user1_dir))
    out = exec_cmd(vls, cert1, '-l {}/{}'.format(work_dir, user1_dir))
    assert_line(test_file_name, ['-rw-------', USER1, 'NONE', 'NONE', '497927'], out)

    # user2 cannot list, copy from/to, move from/to the directory, delete
    out = exec_cmd(vcp, cert2, '{}/{}/{} .'.format(work_dir, user1_dir, test_file_name))
    assert 'NotAuthorized' in out
    out = exec_cmd(vcp, cert2, '{} {}/{}/test.txt'.format(test_file, work_dir, user1_dir))
    assert 'NotAuthorized' in out
    out = exec_cmd(vmkdir, cert2, '{}/{}/somedir'.format(work_dir, user1_dir))
    assert 'NotAuthorized' in out
    out = exec_cmd(vmv, cert2, '{1}/{2}/{0} {1}/{2}/test.txt'.format(
        test_file_name, work_dir, user1_dir))
    assert 'NotAuthorized' in out

